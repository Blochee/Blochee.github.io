<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>51单片机</title>
      <link href="/2023/11/20/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
      <url>/2023/11/20/%E5%8D%95%E7%89%87%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="51单片机"><a href="#51单片机" class="headerlink" title="51单片机"></a>51单片机</h1><h2 id="LCD1602"><a href="#LCD1602" class="headerlink" title="LCD1602"></a>LCD1602</h2><pre><code class="c">//main.c#include &lt;REGX52.H&gt;#include &quot;LCD1602.h&quot;void main()&#123;    LCD_Init();  LCD_ShowChar(1,1,&#39;A&#39;);  LCD_ShowString(1,3,&quot;abc&quot;);  LCD_ShowNum(1,7,123,3);  LCD_ShowSignedNum(1,12,-64,2);  LCD_ShowHexNum(2,1,0xA2,2);  LCD_ShowBinNum(2,5,0xA8,8);    while(1)    &#123;            &#125;&#125;</code></pre><pre><code class="c">//LCD1602.h#ifndef __LCD1602_H__#define __LCD1602_H__//用户调用函数：void LCD_Init();void LCD_ShowChar(unsigned char Line,unsigned char Column,char Char);void LCD_ShowString(unsigned char Line,unsigned char Column,char *String);void LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);void LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length);void LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);void LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);#endif</code></pre><pre><code class="c">//LCD1602.c#include &lt;REGX52.H&gt;//引脚配置：sbit LCD_RS=P2^5;sbit LCD_RW=P2^4;sbit LCD_EN=P2^3;#define LCD_DataPort P0//函数定义：/**  * @brief  LCD1602延时函数，12MHz调用可延时1ms  * @param  无  * @retval 无  */void LCD_Delay()&#123;    unsigned char i, j;    i = 2;    j = 239;    do    &#123;        while (--j);    &#125; while (--i);&#125;/**  * @brief  LCD1602写命令  * @param  Command 要写入的命令  * @retval 无  */void LCD_WriteCommand(unsigned char Command)&#123;    LCD_RS=0;    LCD_RW=0;    LCD_DataPort=Command;    LCD_EN=1;    LCD_Delay();    LCD_EN=0;    LCD_Delay();&#125;/**  * @brief  LCD1602写数据  * @param  Data 要写入的数据  * @retval 无  */void LCD_WriteData(unsigned char Data)&#123;    LCD_RS=1;    LCD_RW=0;    LCD_DataPort=Data;    LCD_EN=1;    LCD_Delay();    LCD_EN=0;    LCD_Delay();&#125;/**  * @brief  LCD1602设置光标位置  * @param  Line 行位置，范围：1~2  * @param  Column 列位置，范围：1~16  * @retval 无  */void LCD_SetCursor(unsigned char Line,unsigned char Column)&#123;    if(Line==1)    &#123;        LCD_WriteCommand(0x80|(Column-1));    &#125;    else if(Line==2)    &#123;        LCD_WriteCommand(0x80|(Column-1+0x40));    &#125;&#125;/**  * @brief  LCD1602初始化函数  * @param  无  * @retval 无  */void LCD_Init()&#123;    LCD_WriteCommand(0x38);//八位数据接口，两行显示，5*7点阵    LCD_WriteCommand(0x0c);//显示开，光标关，闪烁关    LCD_WriteCommand(0x06);//数据读写操作后，光标自动加一，画面不动    LCD_WriteCommand(0x01);//光标复位，清屏&#125;/**  * @brief  在LCD1602指定位置上显示一个字符  * @param  Line 行位置，范围：1~2  * @param  Column 列位置，范围：1~16  * @param  Char 要显示的字符  * @retval 无  */void LCD_ShowChar(unsigned char Line,unsigned char Column,char Char)&#123;    LCD_SetCursor(Line,Column);    LCD_WriteData(Char);&#125;/**  * @brief  在LCD1602指定位置开始显示所给字符串  * @param  Line 起始行位置，范围：1~2  * @param  Column 起始列位置，范围：1~16  * @param  String 要显示的字符串  * @retval 无  */void LCD_ShowString(unsigned char Line,unsigned char Column,char *String)&#123;    unsigned char i;    LCD_SetCursor(Line,Column);    for(i=0;String[i]!=&#39;\0&#39;;i++)    &#123;        LCD_WriteData(String[i]);    &#125;&#125;/**  * @brief  返回值=X的Y次方  */int LCD_Pow(int X,int Y)&#123;    unsigned char i;    int Result=1;    for(i=0;i&lt;Y;i++)    &#123;        Result*=X;    &#125;    return Result;&#125;/**  * @brief  在LCD1602指定位置开始显示所给数字  * @param  Line 起始行位置，范围：1~2  * @param  Column 起始列位置，范围：1~16  * @param  Number 要显示的数字，范围：0~65535  * @param  Length 要显示数字的长度，范围：1~5  * @retval 无  */void LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)&#123;    unsigned char i;    LCD_SetCursor(Line,Column);    for(i=Length;i&gt;0;i--)    &#123;        LCD_WriteData(Number/LCD_Pow(10,i-1)%10+&#39;0&#39;);    &#125;&#125;/**  * @brief  在LCD1602指定位置开始以有符号十进制显示所给数字  * @param  Line 起始行位置，范围：1~2  * @param  Column 起始列位置，范围：1~16  * @param  Number 要显示的数字，范围：-32768~32767  * @param  Length 要显示数字的长度，范围：1~5  * @retval 无  */void LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length)&#123;    unsigned char i;    unsigned int Number1;    LCD_SetCursor(Line,Column);    if(Number&gt;=0)    &#123;        LCD_WriteData(&#39;+&#39;);        Number1=Number;    &#125;    else    &#123;        LCD_WriteData(&#39;-&#39;);        Number1=-Number;    &#125;    for(i=Length;i&gt;0;i--)    &#123;        LCD_WriteData(Number1/LCD_Pow(10,i-1)%10+&#39;0&#39;);    &#125;&#125;/**  * @brief  在LCD1602指定位置开始以十六进制显示所给数字  * @param  Line 起始行位置，范围：1~2  * @param  Column 起始列位置，范围：1~16  * @param  Number 要显示的数字，范围：0~0xFFFF  * @param  Length 要显示数字的长度，范围：1~4  * @retval 无  */void LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)&#123;    unsigned char i,SingleNumber;    LCD_SetCursor(Line,Column);    for(i=Length;i&gt;0;i--)    &#123;        SingleNumber=Number/LCD_Pow(16,i-1)%16;        if(SingleNumber&lt;10)        &#123;            LCD_WriteData(SingleNumber+&#39;0&#39;);        &#125;        else        &#123;            LCD_WriteData(SingleNumber-10+&#39;A&#39;);        &#125;    &#125;&#125;/**  * @brief  在LCD1602指定位置开始以二进制显示所给数字  * @param  Line 起始行位置，范围：1~2  * @param  Column 起始列位置，范围：1~16  * @param  Number 要显示的数字，范围：0~1111 1111 1111 1111  * @param  Length 要显示数字的长度，范围：1~16  * @retval 无  */void LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)&#123;    unsigned char i;    LCD_SetCursor(Line,Column);    for(i=Length;i&gt;0;i--)    &#123;        LCD_WriteData(Number/LCD_Pow(2,i-1)%2+&#39;0&#39;);    &#125;&#125;</code></pre><h2 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h2><h3 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h3><pre><code class="c">//main.c#include &lt;REGX52.H&gt;#include &quot;Delay.h&quot;#include &quot;LCD1602.h&quot;#include &quot;MatrixKey.h&quot;unsigned char KeyNum;void main()&#123;    LCD_Init();        while(1)    &#123;        KeyNum=MatrixKey();        if(KeyNum)        &#123;            LCD_ShowNum(2,1,KeyNum,2);        &#125;    &#125;&#125;</code></pre><pre><code class="c">//MatrixKey.h#ifndef __MATRIXKEY_H__#define __MATRIXKEY_H__//用户调用函数：unsigned char MatrixKey();#endif</code></pre><pre><code class="c">//MatrixKey.c#include &lt;REGX52.H&gt;#include &quot;Delay.h&quot;unsigned char MatrixKey()&#123;    unsigned char Keynumber=0;        P1=0xFF;    P1_3=0;    if(P1_7==0)&#123;Delay(20);while(P1_7==0);Delay(20);Keynumber=1;&#125;    if(P1_6==0)&#123;Delay(20);while(P1_6==0);Delay(20);Keynumber=5;&#125;    if(P1_5==0)&#123;Delay(20);while(P1_5==0);Delay(20);Keynumber=9;&#125;    if(P1_4==0)&#123;Delay(20);while(P1_4==0);Delay(20);Keynumber=13;&#125;        P1=0xFF;    P1_2=0;    if(P1_7==0)&#123;Delay(20);while(P1_7==0);Delay(20);Keynumber=2;&#125;    if(P1_6==0)&#123;Delay(20);while(P1_6==0);Delay(20);Keynumber=6;&#125;    if(P1_5==0)&#123;Delay(20);while(P1_5==0);Delay(20);Keynumber=10;&#125;    if(P1_4==0)&#123;Delay(20);while(P1_4==0);Delay(20);Keynumber=14;&#125;        P1=0xFF;    P1_1=0;    if(P1_7==0)&#123;Delay(20);while(P1_7==0);Delay(20);Keynumber=3;&#125;    if(P1_6==0)&#123;Delay(20);while(P1_6==0);Delay(20);Keynumber=7;&#125;    if(P1_5==0)&#123;Delay(20);while(P1_5==0);Delay(20);Keynumber=11;&#125;    if(P1_4==0)&#123;Delay(20);while(P1_4==0);Delay(20);Keynumber=15;&#125;        P1=0xFF;    P1_0=0;    if(P1_7==0)&#123;Delay(20);while(P1_7==0);Delay(20);Keynumber=4;&#125;    if(P1_6==0)&#123;Delay(20);while(P1_6==0);Delay(20);Keynumber=8;&#125;    if(P1_5==0)&#123;Delay(20);while(P1_5==0);Delay(20);Keynumber=12;&#125;    if(P1_4==0)&#123;Delay(20);while(P1_4==0);Delay(20);Keynumber=16;&#125;        return Keynumber;&#125;</code></pre><h3 id="电子密码锁"><a href="#电子密码锁" class="headerlink" title="电子密码锁"></a>电子密码锁</h3><pre><code class="c">#include &lt;REGX52.H&gt;#include &quot;Delay.h&quot;#include &quot;LCD1602.h&quot;#include &quot;MatrixKey.h&quot;unsigned char KeyNum;unsigned int Password;unsigned int Count; //全局变量默认为0，不用赋初值void main()&#123;    LCD_Init();    LCD_ShowString(1,1,&quot;Password:&quot;);        while(1)    &#123;        KeyNum=MatrixKey();        if(KeyNum)        &#123;            if(KeyNum&lt;=10)//如果s1~s10按下输入密码            &#123;                if(Count&lt;4)//如果输入次数小于4                &#123;                Password*=10;                Password+=KeyNum%10; //获取一位密码                &#125;                Count++;  //计数次数加一                LCD_ShowNum(2,1,Password,4);//更新显示            &#125;            if(KeyNum==11) //如果s11按下，确认            &#123;                if(Password==2345)//正确密码                &#123;                        LCD_ShowString(1,14,&quot;OK &quot;);                        Password=0;//密码清零，计数清零                        Count=0;                        LCD_ShowNum(2,1,Password,4);//更新显示                &#125;                else                &#123;                        LCD_ShowString(1,14,&quot;ERR&quot;);                      Password=0;//密码清零，计数清零                        Count=0;                        LCD_ShowNum(2,1,Password,4);//更新显示                &#125;            &#125;                                if(KeyNum==12)                &#123;                    Password=0;//密码清零，计数清零                    Count=0;                    LCD_ShowNum(2,1,Password,4);//更新显示                &#125;                    &#125;    &#125;&#125;</code></pre><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="基础应用-1"><a href="#基础应用-1" class="headerlink" title="基础应用"></a>基础应用</h3><pre><code class="c">//main.c#include &lt;REGX52.H&gt;#include &quot;Time0.h&quot;#include &quot;Key.h&quot;#include &lt;INTRINS.H&gt;unsigned char KeyNum;unsigned char LEDMode;void main()&#123;    P0=0x01;    Timer0_Init();    while(1)    &#123;        KeyNum=Key();        if(KeyNum)        &#123;            if(KeyNum==1)            &#123;                LEDMode++;                if(LEDMode&gt;=2)LEDMode=0;            &#125;        &#125;    &#125;&#125;void Timer0_Routine() interrupt 1&#123;    static unsigned int T0Count;    TL0 = 0xCD;//设置定时初始值    TH0 = 0xF8;//设置定时初始值    T0Count++;    if(T0Count&gt;=1000)    &#123;        T0Count=0;        if(LEDMode==0)        &#123;            P0=_crol_(P0,1);//循环左移        &#125;        if(LEDMode==1)        &#123;            P0=_cror_(P0,1);//循环右移        &#125;            &#125;&#125;</code></pre><pre><code class="c">//Key.h#ifndef__KEY_H__#define__KEY_H__unsigned char Key();#endif</code></pre><pre><code class="c">//Key.c#include &lt;REGX52.H&gt;#include &quot;Delay.h&quot;unsigned char Key()&#123;    unsigned char KeyNumber=0;        if(P1_0==0)&#123;Delay(20);while(P1_0==0);Delay(20);KeyNumber=1;&#125;    if(P1_1==0)&#123;Delay(20);while(P1_1==0);Delay(20);KeyNumber=2;&#125;    if(P1_2==0)&#123;Delay(20);while(P1_2==0);Delay(20);KeyNumber=3;&#125;    if(P1_3==0)&#123;Delay(20);while(P1_3==0);Delay(20);KeyNumber=4;&#125;    if(P1_4==0)&#123;Delay(20);while(P1_4==0);Delay(20);KeyNumber=5;&#125;    if(P1_5==0)&#123;Delay(20);while(P1_5==0);Delay(20);KeyNumber=6;&#125;    if(P1_6==0)&#123;Delay(20);while(P1_6==0);Delay(20);KeyNumber=7;&#125;    if(P1_7==0)&#123;Delay(20);while(P1_7==0);Delay(20);KeyNumber=8;&#125;        return KeyNumber;    &#125;</code></pre><pre><code class="c">//Time0.h#ifndef__TIME0_H__#define__TIME0_H__void Timer0_Init(void);#endif</code></pre><pre><code class="c">//Time0.c#include &lt;REGX52.H&gt;//stc-isp软件生成void Timer0_Init(void)//1毫秒@22.1184MHz&#123;        TMOD &amp;= 0xF0;//设置定时器模式    TMOD |= 0x01;//设置定时器模式    TL0 = 0xCD;//设置定时初始值    TH0 = 0xF8;//设置定时初始值    TF0 = 0;//清除TF0标志    TR0 = 1;//定时器0开始计时    EA=1;    ET0=1;    PT0=0;&#125;//定时器中断函数模板/*void Timer0_Routine() interrupt 1&#123;    static unsigned int T0Count;    TL0 = 0xCD;//设置定时初始值    TH0 = 0xF8;//设置定时初始值    T0Count++;    if(T0Count&gt;=1000)    &#123;        T0Count=0;            &#125;&#125;*///自己写的/*void Timer0_Init()&#123;    //TMOD=0x01;    TMOD=TMOD&amp;0xF0;//把TMOD的低四位清零，高四位不变    TMOD=TMOD|0x01;//把最低位置1，其余不变    TF0=0;    TR0=1;    TH0=63693/256;    TL0=63693%256;    EA=1;    ET0=1;    PT0=0;&#125;*/</code></pre><h3 id="时钟设计"><a href="#时钟设计" class="headerlink" title="时钟设计"></a>时钟设计</h3><pre><code class="c">//main.c#include &lt;REGX52.H&gt;#include &quot;Delay.h&quot;#include &quot;LCD1602.h&quot;#include &quot;Time0.h&quot;unsigned char Sec,Min,Hour;void main()&#123;    LCD_Init();    Timer0_Init();        LCD_ShowString(1,1,&quot;clock:&quot;);    LCD_ShowString(2,1,&quot;  :  :&quot;);        while(1)    &#123;        LCD_ShowNum(2,1,Hour,2);        LCD_ShowNum(2,4,Min,2);        LCD_ShowNum(2,7,Sec,2);    &#125;&#125;void Timer0_Routine() interrupt 1&#123;    static unsigned int T0Count;    TL0 = 0xCD;//设置定时初始值    TH0 = 0xF8;//设置定时初始值    T0Count++;    if(T0Count&gt;=1000)    &#123;        T0Count=0;        Sec++;        if(Sec&gt;=60)        &#123;            Sec=0;            Min++;            if(Min&gt;=60)            &#123;                Min=0;                Hour++;                if(Hour&gt;=24)                &#123;                    Hour=0;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32</title>
      <link href="/2023/11/20/STM32/"/>
      <url>/2023/11/20/STM32/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h1><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><ol><li>USART是STM32内部集成的硬件外设，可以根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去。也可以自动接收RX引脚的数据帧时序，拼接位一个字节数据，存放在数据寄存器里面。</li></ol><p>这是串口发送部分的代码</p><pre><code class="c">//Serial.c#include &quot;stm32f10x.h&quot;#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;void Serial_Init(void)&#123;    USART_InitTypeDef USART_InitStruct;//初始化USART                 GPIO_InitTypeDef GPIO_InitStructure;//初始化GPIO        //开启APB2总线上USART1和GPIOA的内部时钟，STM32F103的USART2和USART3都是挂在APB1总线上的    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);      //GPIO结构体参数的配置    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//配置GPIOA的模式    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 ;//配置GPIOA使用的引脚    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//配置GPIOA的传输速率    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);//初始化        USART_InitStruct.USART_BaudRate=9600 ;//配置USART1的波特率    USART_InitStruct.USART_HardwareFlowControl=USART_HardwareFlowControl_None ;    USART_InitStruct.USART_Mode=USART_Mode_Tx ;//配置USART的模式    USART_InitStruct.USART_Parity=USART_Parity_No ;    USART_InitStruct.USART_StopBits=USART_StopBits_1 ;//停止位    USART_InitStruct.USART_WordLength=USART_WordLength_8b ;//有效数据字长    USART_Init(USART1,&amp;USART_InitStruct);    USART_Cmd(USART1,ENABLE);//开启USART1&#125;void Serial_SendByte(uint8_t Byte)//发送一个字节的数据&#123;   //发送数据到TDR寄存器中   USART_SendData(USART1,Byte);   //当数据从TDR寄存器中到输出移位寄存器中时，TXE标志位置1    while (USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);&#125;void Serial_SendArray(uint8_t *Array,uint16_t Length)//发送一个数组&#123;  uint16_t i;  for(i=0;i&lt;Length;i++)  &#123;    Serial_SendByte(Array[i]);  &#125;&#125;void Serial_SendString(char *String)//发送一个字符串&#123;  uint8_t i;  for(i=0;String[i]!=&#39;\0&#39;;i++)  &#123;    Serial_SendByte(String[i]);  &#125;&#125;uint32_t Serial_Pow(uint32_t X,uint32_t Y)//计算Y个X的值，即X的Y次方&#123;  uint32_t Result=1;  while(Y--)  &#123;    Result*=X;  &#125;  return Result;&#125;void Serial_SendNumber(uint32_t Number,uint8_t Length)//发送一个数字&#123;    uint8_t i;    for(i=0;i&lt;Length;i++)    &#123;      Serial_SendByte((Number / Serial_Pow(10,Length-i-1)) %10+&#39;0&#39;);    &#125;&#125;//重写printf函数底层，这样主函数中就可以调用Printf函数输出在串口上，但缺点是只能在一个串口中使用int fputc(int ch,FILE *f)&#123;  Serial_SendByte(ch);  return ch;&#125;//重定向到字符串，可以将数字映射到字符中，这样就可以调用此函数达到Printf函数达到相同的功能void Serial_Printf(char *format, ...)&#123;  char String[100];  va_list arg;  va_start(arg,format);  vsprintf(String,format,arg);  va_end(arg);  Serial_SendString(String);&#125;</code></pre><pre><code class="c">//Serial.h#ifndef __SERIAL_H__#define __SERIAL_H__#include &lt;stdio.h&gt;//这样主函数就不需要写这个头文件void Serial_Init(void);void Serial_SendByte(uint8_t Byte);void Serial_SendArray(uint8_t *Array,uint16_t Length);void Serial_SendString(char *String);void Serial_SendNumber(uint32_t Number,uint8_t Length);void Serial_Printf(char *format, ...);#endif</code></pre><pre><code class="c">#include &quot;stm32f10x.h&quot;  // Device header#include &quot;Delay.h&quot;#include &quot;OLED.h&quot;#include &quot;Serial.h&quot;/uint8_t MyArray[]=&#123;0x42,0x43,0x44,0x45&#125;;/char String[100];int main(void)&#123;    OLED_Init();    Serial_Init();    Serial_SendByte(&#39;B&#39;);    Serial_SendArray(MyArray,4);    Serial_SendString(&quot;helloworld!\r\n&quot;);    Serial_SendNumber(12345,5);    Serial_SendString(&quot;\r\n&quot;);        printf(&quot;Num=%d\r\n&quot;,666);    sprintf(String,&quot;Num=%d\r\n&quot;,666);//重定向到字符串中    Serial_SendString(String);    Serial_Printf(&quot;你好，世界&quot;);//必须保证编码形式相同，最好用UTF-8形式编码，避免中文乱码    while(1)    &#123;            &#125;&#125;</code></pre><p>这是串口发送加接收部分的代码</p><pre><code class="c">#include &quot;stm32f10x.h&quot;#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;uint8_t Serial_RxData;//接收数据uint8_t Serial_RxFlag;//接收标志位void Serial_Init(void)&#123;    USART_InitTypeDef USART_InitStruct;    GPIO_InitTypeDef GPIO_InitStructure;        NVIC_InitTypeDef NVIC_InitStruct;//采用中断方式接收，需配置NVIC          RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//复用推挽输出    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 ;    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;//上拉输入    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 ;//接收数据引脚    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);        USART_InitStruct.USART_BaudRate=9600 ;    USART_InitStruct.USART_HardwareFlowControl=USART_HardwareFlowControl_None ;    USART_InitStruct.USART_Mode=USART_Mode_Tx |USART_Mode_Rx ;//发送+接收    USART_InitStruct.USART_Parity=USART_Parity_No ;    USART_InitStruct.USART_StopBits=USART_StopBits_1 ;    USART_InitStruct.USART_WordLength=USART_WordLength_8b ;    USART_Init(USART1,&amp;USART_InitStruct);        USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);//开启RXNE标志位中断    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//中断组        NVIC_InitStruct.NVIC_IRQChannel=USART1_IRQn;    NVIC_InitStruct.NVIC_IRQChannelCmd=ENABLE;    NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority=1;    NVIC_InitStruct.NVIC_IRQChannelSubPriority=1;    NVIC_Init(&amp;NVIC_InitStruct);        USART_Cmd(USART1,ENABLE);&#125;void Serial_SendByte(uint8_t Byte)&#123;    USART_SendData(USART1,Byte);   while (USART_GetFlagStatus(USART1,USART_FLAG_TXE)==RESET);&#125;void Serial_SendArray(uint8_t *Array,uint16_t Length)&#123;  uint16_t i;  for(i=0;i&lt;Length;i++)  &#123;    Serial_SendByte(Array[i]);  &#125;&#125;void Serial_SendString(char *String)&#123;  uint8_t i;  for(i=0;String[i]!=&#39;\0&#39;;i++)  &#123;    Serial_SendByte(String[i]);  &#125;&#125;uint32_t Serial_Pow(uint32_t X,uint32_t Y)&#123;  uint32_t Result=1;  while(Y--)  &#123;    Result*=X;  &#125;  return Result;&#125;void Serial_SendNumber(uint32_t Number,uint8_t Length)&#123;    uint8_t i;    for(i=0;i&lt;Length;i++)    &#123;      Serial_SendByte((Number / Serial_Pow(10,Length-i-1)) %10+&#39;0&#39;);    &#125;&#125;//重写printf函数底层int fputc(int ch,FILE *f)&#123;  Serial_SendByte(ch);  return ch;&#125;//重定向到字符串void Serial_Printf(char *format, ...)&#123;  char String[100];  va_list arg;  va_start(arg,format);  vsprintf(String,format,arg);  va_end(arg);  Serial_SendString(String);&#125;uint8_t Serial_GetRxFlag(void)&#123;  if(Serial_RxFlag==1)  &#123;    Serial_RxFlag=0;    return 1;  &#125;  return 0;&#125;uint8_t Serial_GetRxData(void)&#123;  return Serial_RxData;&#125;void USART1_IRQHandler(void)//接收数据中断函数，这个函数名是固定的&#123;    if(USART_GetFlagStatus(USART1,USART_IT_RXNE)==SET)    &#123;        Serial_RxData = USART_ReceiveData(USART1);        Serial_RxFlag = 1;        USART_ClearITPendingBit(USART1,USART_IT_RXNE);//清除中断标志位    &#125;    &#125;</code></pre><pre><code class="c">//Serial.h#ifndef __SERIAL_H__#define __SERIAL_H__#include &lt;stdio.h&gt;void Serial_Init(void);void Serial_SendByte(uint8_t Byte);void Serial_SendArray(uint8_t *Array,uint16_t Length);void Serial_SendString(char *String);void Serial_SendNumber(uint32_t Number,uint8_t Length);void Serial_Printf(char *format, ...);uint8_t Serial_GetRxFlag(void);uint8_t Serial_GetRxData(void);#endif</code></pre><pre><code class="c">//main.c#include &quot;stm32f10x.h&quot;  // Device header#include &quot;Delay.h&quot;#include &quot;OLED.h&quot;#include &quot;Serial.h&quot;uint8_t RxData;int main(void)&#123;    OLED_Init();    OLED_ShowString(1,1,&quot;RxData:&quot;);    Serial_Init();    while(1)    &#123;        if(Serial_GetRxFlag()==1)        &#123;            RxData = Serial_GetRxData();            Serial_SendByte(RxData);            OLED_ShowHexNum(1,8,RxData,2);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

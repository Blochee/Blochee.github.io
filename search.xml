<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>指令系统</title>
      <link href="/2023/11/24/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/11/24/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Pentium的寻址方式"><a href="#Pentium的寻址方式" class="headerlink" title="Pentium的寻址方式"></a>Pentium的寻址方式</h2><p>寻址方式：指令中提供操作数或操作数地址的方式</p><h3 id="立即数寻址（Immediate-Addressing）"><a href="#立即数寻址（Immediate-Addressing）" class="headerlink" title="立即数寻址（Immediate Addressing）"></a>立即数寻址（Immediate Addressing）</h3><p>操作数直接包含在指令当中</p><p>例如</p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231124204220093.png" alt="image-20231124204220093"></p><h3 id="寄存器寻址（Register-Addressing）"><a href="#寄存器寻址（Register-Addressing）" class="headerlink" title="寄存器寻址（Register Addressing）"></a>寄存器寻址（Register Addressing）</h3><p>操作数在CPU内部寄存器中，寄存器名在指令中指出</p><p>CPU内部寄存器如下：</p><p>8位：AH、AL、BH、BL、CH、CL、DH、DL</p><p>16位：AX、BX、CX、DX、SI、DI、SP、BP</p><p>32位：EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP</p><p>例如：    MOV DS,AX—————AX里面的内容送到DS中</p><h3 id="输入-输出端口寻址"><a href="#输入-输出端口寻址" class="headerlink" title="输入&#x2F;输出端口寻址"></a>输入&#x2F;输出端口寻址</h3><p>CPU和外设交换数据均通过I&#x2F;O接口中的端口进行</p><h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>I&#x2F;O端口的地址直接在指令中给出</p><p>例如：IN  AL,80H        OUT   81H,AL         </p><p>寻址范围：00H——FFH（0~255）</p><h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><p>I&#x2F;O端口的地址在寄存器DX中</p><p>例如：IN  AL,DX    OUT  DX,AL</p><p>寻址范围：0000H——FFFFH（0~65535）</p><h3 id="存储器寻址"><a href="#存储器寻址" class="headerlink" title="存储器寻址"></a>存储器寻址</h3><p>存储器中操作数的地址：段地址+偏移量（有效地址）</p><p>段基址一般不太变化，而有效地址却是变化多端</p><h4 id="直接寻址-1"><a href="#直接寻址-1" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>指操作数的<strong>有效地址</strong>直接包含在指令中</p><p>例如： MOV    AX,DS:[2000H]             如图：低字节在前，高字节在后</p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231124205839716.png" alt="image-20231124205839716"></p><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>操作数的有效地址放在指令给出的寄存器中</p><ol><li>操作数的16位段内偏移地址放在：AX、<strong>BX</strong>、CX、DX、<strong>SI</strong>、<strong>DI</strong>、BP、SP</li><li>操作数的32位段内偏移地址放在：EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP</li></ol><p>注意：</p><ul><li><p>这些寄存器通常称为<strong>地址指针</strong>或者间址寄存器</p></li><li><p>因SI、DI又称为变址寄存器，所以使用这两个寄存器的寻址方式又叫变址寻址</p></li><li><p>默认段基址：</p><p>以BP，SP间接寻址：操作数默认存放在堆栈段SS中</p></li></ul><p>其它：操作数默认存放在数据段寄存器DS中</p><p>例如：</p><p>MOV AX,[SI]</p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231124210652830.png" alt="image-20231124210652830"></p><h4 id="寄存器相对寻址"><a href="#寄存器相对寻址" class="headerlink" title="寄存器相对寻址"></a>寄存器相对寻址</h4><p>操作数的有效地址是指令中给出的寄存器和位移量的和</p><ul><li><p>位移量可正可负，被看成是对寄存器所指地址的一个相对值</p></li><li><p>常用于表格处理：位移量为表格首地址，通过修改寄存器的内容指向表格中的某一项</p></li><li><p>用BP寻址时，以堆栈段寄存器SS作为地址基准，用SI，DI或BX一般以DS作为地址基准</p></li></ul><p>例如：   MOV  AX,DISP[SI]</p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231124211451535.png" alt="image-20231124211451535"></p><h4 id="基址加变址寻址"><a href="#基址加变址寻址" class="headerlink" title="基址加变址寻址"></a>基址加变址寻址</h4><p>操作数的有效地址是基址和变址的和</p><p>通常把BX和BP作为基址寄存器，而把SI、DI作为变址寄存器。将这两种寄存器联合起来进行的寻址就称为基址加变址寻址</p><p>段寄存器选用规则：</p><ul><li>若用BX作为基址寄存器，则操作数应放在数据段DS区域中</li><li>若用BP作为基址寄存器，则操作数应放在堆栈段SS区域中</li></ul><p>常用于表格或数组的处理：</p><p>基址寄存器存放表格或数组的首地址，用变址寄存器指向表格或数组的某一项</p><p>例如：  MOV AX,[BX] [SI]</p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231124211845225.png" alt="image-20231124211845225"></p><h4 id="相对的基址加变址寻址"><a href="#相对的基址加变址寻址" class="headerlink" title="相对的基址加变址寻址"></a>相对的基址加变址寻址</h4><p>EA&#x3D;基址+变址+位移量</p><p>例如：   MOV AX，DISP［BX]［SI］</p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231124212101661.png" alt="image-20231124212101661"></p><h4 id="相对的带比例因子的变址寻址"><a href="#相对的带比例因子的变址寻址" class="headerlink" title="相对的带比例因子的变址寻址"></a>相对的带比例因子的变址寻址</h4><p>EA&#x3D;变址*比例因子+位移量</p><p>比例因子为1、2、4、8</p><p>例如：      IMUL   EBX，[ESI*4+07H]</p><h4 id="基址加比例因子的变址寻址"><a href="#基址加比例因子的变址寻址" class="headerlink" title="基址加比例因子的变址寻址"></a>基址加比例因子的变址寻址</h4><p>EA&#x3D;基址+变址×比例因子</p><p>例如：      MOV EAX，[EBX] [ESI*4]</p><h4 id="相对的基址加比例因子的变址寻址"><a href="#相对的基址加比例因子的变址寻址" class="headerlink" title="相对的基址加比例因子的变址寻址"></a>相对的基址加比例因子的变址寻址</h4><p>EA&#x3D;基址+变址×比例因子+位移量</p><p>例如：      MOV EAX，[EBX] [ESI*4+1200H]</p><h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><p>有些指令的指令码中，不仅包含有操作码信息，而且还隐含了操作数地址的信息</p><p>例如乘法指令MUL的指令码中只需指明一个乘数的地址，另一个乘数和积的地址是隐含固定的（另一个乘数默认为AL, AX，EAX；积默认为AX, DX：AX，或者EDX：EAX）</p><p>这种将操作数的地址隐含在指令操作码中的寻址方式称为隐含寻址</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>EA和PA是存储器才有的概念</p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231124212719865.png" alt="image-20231124212719865"></p><h2 id="Pentium的指令系统"><a href="#Pentium的指令系统" class="headerlink" title="Pentium的指令系统"></a>Pentium的指令系统</h2><h3 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h3><ul><li><p>用来把数据或地址传送到存储器、寄存器或者I&#x2F;O端口中</p></li><li><p>除目的操作数为标志寄存器的指令外，其余指令均不影响标志位</p></li></ul><h4 id="通用传送指令"><a href="#通用传送指令" class="headerlink" title="通用传送指令"></a>通用传送指令</h4><p>MOV      OPRD1    ,   OPRD2</p><p>操作码   目的操作数  源操作数</p><p>源操作数：通用寄存器、段寄存器、存储器、立即数</p><p>目的操作数：通用寄存器、段寄存器、存储器、不能是立即数</p><p>数据传送方向如图：</p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231125222618580.png" alt="image-20231125222618580"></p><p>注意</p><ol><li>MOV指令不能在两个存储器的单元之间进行数据传送</li><li>MOV指令不能在两个段寄存器之间进行数据直接传送</li><li>立即数不能直接传送给段寄存器</li><li>目的操作数不能为CS、IP</li></ol><h4 id="堆栈操作指令"><a href="#堆栈操作指令" class="headerlink" title="堆栈操作指令"></a>堆栈操作指令</h4><p>堆栈是内存中一个特定区域，用来存放CPU暂时不使用，但是又必须保存的数据</p><p>特点：先进后出，后进先出</p><p>存储单元地址由（SS：SP）来决定</p><p>格式（POP指令操作数不能是立即数）</p><ul><li>PUSH OPRD</li><li>POP OPRD</li></ul><p>注意</p><ul><li>堆栈操作总是按照字或双字，不能按字节进行</li><li>入栈时，SP指针减2</li><li>出栈时，SP指针加2</li></ul><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231125223439334.png" alt="image-20231125223439334"></p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231125223456258.png" alt="image-20231125223456258"></p><h4 id="交换指令XCHG"><a href="#交换指令XCHG" class="headerlink" title="交换指令XCHG"></a>交换指令XCHG</h4><p>格式：XCHG OPRD1 ， OPED2</p><p>功能：把一个字节、字或双字的源操作数与目的操作数相交换</p><p>注意：</p><ul><li>目的操作数和源操作数不能同时为内存单元</li><li>段寄存器和IP，EIP不能作为交换指令的操作数</li><li>立即数不能作为XCHG指令的操作数</li></ul><h4 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h4><p>输入指令：IN ACC，PORT    ———从端口到CPU的输入操作</p><p>输出指令：OUT PORT，ACC———从CPU到端口的输出操作</p><ol><li><p>直接寻址</p><p>指令中直接给出一个字节表示端口地址（00H~FFH）</p></li><li><p>寄存器间接寻址</p><p>输入输出指令中端口地址由DX的内容决定（0000H~0FFFFH）</p></li></ol><p>I&#x2F;O指令不影响标志位</p><h4 id="换码指令XLAT"><a href="#换码指令XLAT" class="headerlink" title="换码指令XLAT"></a>换码指令XLAT</h4><p>格式：XLAT（Translate Byte to AL）</p><p>功能：AL←[BX＋AL]</p><p>本条指令完成一个字节的编码转换，转换前要现在内存中建立一个代码装换表</p><h4 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h4><ul><li>取有效地址指令LEA</li></ul><p>格式：LEA REG，SRC</p><p>功能：把存储器单元的有效地址EA送指定的寄存器REG。常用来使一个寄存器作为地址指针</p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231126221416647.png" alt="image-20231126221416647"></p><ul><li>LDS指令</li></ul><p>格式：LDS REG，SRC</p><p>功能：把SRC指定的内存中四个字节的三十二位数据送到段寄存器DS和REG（BX，SI或DI）</p><p>低16位送给REG，高16位送给DS</p><ul><li>LES指令</li></ul><p>格式相同，但是把高16位送给ES</p><h4 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令"></a>标志传送指令</h4><ul><li>读标志指令LAHF</li></ul><p>格式：LAHF</p><p>功能：AH&lt;——FLAGSL（内含5个标志位CF，PF，AF，ZF，SF）</p><ul><li>写标志指令SAHF</li></ul><p>功能FLAGSL&lt;——AH</p><ul><li>FLAGS入栈指令PUSHF</li></ul><p>格式：PUSHF</p><p>功能：FLAGS入栈。入栈操作步骤依次为SP←SP－1，(SS×10H＋SP)←FLAGSH，SP←SP－1，(SS×10H＋SP)←FLAGSL</p><ul><li>FLAGS出栈指令POPF</li></ul><p>格式：POPF</p><p>功能：FLAGS出栈。出栈操作步骤依次为FLAGSL←(SS×10H＋SP)，SP←SP＋1，FLAGSH←(SS×10H＋SP)，SP←SP＋1</p><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><p>运算：加减乘除</p><p>两类数据：无符号数，有符号数</p><p>这些指令可以实现字节，字，双字的运算</p><p>SRC：立即数，通用寄存器，存储器</p><p>DST：通用寄存器，存储器</p><h4 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h4><ul><li><p>ADD OPRD1，OPRD2</p><ol><li>不带进位的两个操作数相加，最后赋值给目的操作数</li><li>会对6个状态标志位OF、SF、ZF、AF、PF、CF</li></ol></li><li><p>ADC OPRD1，OPRD2</p><p>带进位两个操作数相加</p></li><li><p>INC OPRD</p><ol><li>对指定操作数+1操作。+1操作时，把操作数看作为无符号的二进制数</li><li>INC不影响进位标志位CF，而CF的值由上一次的运算结果决定。其它标志位都会影响</li><li>INC指令常用于在循环程序中修改地址指针和循环次数</li></ol></li></ul><h4 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h4><ul><li><p>SUB OPRD1，OPRD2</p><p>不带进位的两个操作数相减，结果送至目的操作数</p></li><li><p>SBB</p><p>相减时要减去进位标志CF</p></li><li><p>DEC OPRD</p><ol><li>减量指令实现对操作数的减1操作</li><li>减1操作时，把操作数看做无符号的二进制数，不影响进位标志CF</li></ol></li><li><p>NEG OPRD</p><ol><li>把操作数当作用补码形式表示的有符号数（有符号数在计算机中都用补码表示）</li><li>具体实现过程：先将操作数用补码的形式来表示，然后对操作数各位（包括符号位）按位取反后加1，所得结果即为原操作数的相反数（依然是补码形式表示的）</li></ol></li><li><p>CMP  OPRD1，OPRD2（该指令也会相减，但是不返回结果，只根据相减的结果修改的标志位）</p></li><li><p>CMP AX，BX</p><ol><li><p>如果ZF&#x3D;1，则两个操作数相等（无论是有符号数还是无符号数），AX&#x3D;BX</p></li><li><p>如果ZF&#x3D;0，则两个操作数不相等</p><ul><li><p>对于无符号数，CF表示借位</p><p>CF&#x3D;0（无借位），AX&gt;BX</p><p>CF&#x3D;1  (有借位)    ，AX&lt;BX</p></li><li><p>对于有符号数</p><p>OF&#x3D;0（没有溢出）</p><ul><li>SF&#x3D;0，则AX&gt;BX</li><li>SF&#x3D;1，则AX&lt;BX</li></ul><p>OF&#x3D;1  (产生溢出)  </p><ul><li>SF&#x3D;0，则AX&lt;BX</li><li>SF&#x3D;1，则AX&gt;BX</li></ul><p> 即</p><p>若OF⊕SF＝0（即OF&#x3D;SF），则AX＞BX<br>若OF⊕SF＝1（即OF≠SF)，则AX＜BX</p></li></ul></li></ol></li></ul><h4 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h4><h4 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h4><h3 id="逻辑运算和移位指令"><a href="#逻辑运算和移位指令" class="headerlink" title="逻辑运算和移位指令"></a>逻辑运算和移位指令</h3><h4 id="逻辑运算指令：AND、OR、NOT、XOR、TEST"><a href="#逻辑运算指令：AND、OR、NOT、XOR、TEST" class="headerlink" title="逻辑运算指令：AND、OR、NOT、XOR、TEST"></a>逻辑运算指令：AND、OR、NOT、XOR、TEST</h4><h4 id="移位指令：SAL、SAR、SHL、SHR、ROL、ROR、RCL、RCR"><a href="#移位指令：SAL、SAR、SHL、SHR、ROL、ROR、RCL、RCR" class="headerlink" title="移位指令：SAL、SAR、SHL、SHR、ROL、ROR、RCL、RCR"></a>移位指令：SAL、SAR、SHL、SHR、ROL、ROR、RCL、RCR</h4><h3 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h3><h4 id="串传送指令MOVSB-MOVSW-MOVSD"><a href="#串传送指令MOVSB-MOVSW-MOVSD" class="headerlink" title="串传送指令MOVSB&#x2F;MOVSW&#x2F;MOVSD"></a>串传送指令MOVSB&#x2F;MOVSW&#x2F;MOVSD</h4><h4 id="串比较指令CMPSB-CMPSW"><a href="#串比较指令CMPSB-CMPSW" class="headerlink" title="串比较指令CMPSB&#x2F;CMPSW"></a>串比较指令CMPSB&#x2F;CMPSW</h4><h4 id="串扫描指令SCASB／SCASW"><a href="#串扫描指令SCASB／SCASW" class="headerlink" title="串扫描指令SCASB／SCASW"></a>串扫描指令SCASB／SCASW</h4><h4 id="取串LODSB／LODSW"><a href="#取串LODSB／LODSW" class="headerlink" title="取串LODSB／LODSW"></a>取串LODSB／LODSW</h4><h4 id="存串STOSB／STOSW"><a href="#存串STOSB／STOSW" class="headerlink" title="存串STOSB／STOSW"></a>存串STOSB／STOSW</h4><h3 id="程序控制指令"><a href="#程序控制指令" class="headerlink" title="程序控制指令"></a>程序控制指令</h3><h4 id="转移地址的寻址方式"><a href="#转移地址的寻址方式" class="headerlink" title="转移地址的寻址方式"></a>转移地址的寻址方式</h4><h4 id="子程序调用和返回"><a href="#子程序调用和返回" class="headerlink" title="子程序调用和返回"></a>子程序调用和返回</h4><h4 id="无条件转移和条件转移指令"><a href="#无条件转移和条件转移指令" class="headerlink" title="无条件转移和条件转移指令"></a>无条件转移和条件转移指令</h4><h4 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h4><h4 id="中断和返回指令"><a href="#中断和返回指令" class="headerlink" title="中断和返回指令"></a>中断和返回指令</h4><h3 id="标志操作和处理器控制指令"><a href="#标志操作和处理器控制指令" class="headerlink" title="标志操作和处理器控制指令"></a>标志操作和处理器控制指令</h3><h4 id="标志操作指令"><a href="#标志操作指令" class="headerlink" title="标志操作指令"></a>标志操作指令</h4><h4 id="外部同步指令"><a href="#外部同步指令" class="headerlink" title="外部同步指令"></a>外部同步指令</h4><h4 id="空操作指令NOP"><a href="#空操作指令NOP" class="headerlink" title="空操作指令NOP"></a>空操作指令NOP</h4><h3 id="条件测试和字节设置指令"><a href="#条件测试和字节设置指令" class="headerlink" title="条件测试和字节设置指令"></a>条件测试和字节设置指令</h3><h3 id="位处理指令"><a href="#位处理指令" class="headerlink" title="位处理指令"></a>位处理指令</h3><h3 id="系统管理指令"><a href="#系统管理指令" class="headerlink" title="系统管理指令"></a>系统管理指令</h3><h3 id="支持高级语言的指令"><a href="#支持高级语言的指令" class="headerlink" title="支持高级语言的指令"></a>支持高级语言的指令</h3><h2 id="汇编语言和汇编程序"><a href="#汇编语言和汇编程序" class="headerlink" title="汇编语言和汇编程序"></a>汇编语言和汇编程序</h2>]]></content>
      
      
      <categories>
          
          <category> 微机原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>硬件结构</title>
      <link href="/2023/11/20/%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2023/11/20/%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="8086的编程结构"><a href="#8086的编程结构" class="headerlink" title="8086的编程结构"></a>8086的编程结构</h2><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231120231029678.png" alt="image-20231120231029678"></p><p>从功能上分成两部分</p><p>总线接口部件（BIU）：负责与存储器、I&#x2F;O端口传送数据</p><p>执行部件（EU）：负责指令的译码和执行</p><h3 id="总线接口部件BIU（Bus-Interface-Unit"><a href="#总线接口部件BIU（Bus-Interface-Unit" class="headerlink" title="总线接口部件BIU（Bus Interface Unit)"></a>总线接口部件BIU（Bus Interface Unit)</h3><ol><li>4个段地址寄存器</li></ol><ul><li>CS：16位的代码段寄存器（code segment）</li><li>DS：16位的数据段寄存器（data segment）</li><li>ES：16位的附加段寄存器（extra segment）</li><li>SS：16位的堆栈段寄存器（stack segment）</li></ul><ol start="2"><li>16位的指令指针寄存器IP（instruction pointer)</li><li>20位的地址加法器：16位的寄存器进行20位的地址寻址</li><li>6字节的指令队列缓冲器</li><li>总线控制逻辑</li></ol><h3 id="执行部件EU（Execution-Unit）"><a href="#执行部件EU（Execution-Unit）" class="headerlink" title="执行部件EU（Execution Unit）"></a>执行部件EU（Execution Unit）</h3><ol><li>4个通用数据寄存器</li></ol><ul><li>AX(Accumulator)：累加器。用于存放操作数。亦可存放存储单元的偏移地址。16位AX&#x3D;高8位AH+低8位AL</li><li>BX(Base) ：基址寄存器。用于存放存储单元的偏移地址。BX&#x3D;BH+BL</li><li>CX(Counter)：计数器。用于多种指令（如串操作指令，移位指令，LOOP指令等）的计数值。亦可存放存储单元的偏移地址。 CX&#x3D;CH+CL</li><li>DX(Data):数据寄存器。用于保存乘法运算的部分积，或除法运算的部分被除数。亦可存放存储单<br>元的偏移地址。DX&#x3D;DH+DL</li></ul><ol start="2"><li>4个专用寄存器</li></ol><ul><li>基数指针寄存器BP(base pointer)：存放堆栈段基地址</li><li>堆栈指针寄存器SP(stack pointer)：用于寻址堆栈段</li><li>源变址寄存器SI(source index)：用于寻址串操作指令的源操作数</li><li>目的变址寄存器DI(destination index)：用于寻址串操作指令的目的操作数</li></ul><ol start="3"><li><p>算术逻辑部件ALU(arithmetic logic unit)</p></li><li><p>标志寄存器FLAGS：一共有16位，其中7位未用</p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231120232039714.png" alt="image-20231120232039714"></p></li></ol><p>​6个状态标志位</p><ul><li>符号标志SF(sign flag ) ：表示运算结果的符号，0表示正，1表示负</li><li>零标志ZF(zero flag) ：如运算结果为0，则ZF&#x3D;1，否则，ZF&#x3D;0</li><li>奇偶标志PF(parity flag) ：运算结果的低8位所含1的个数为偶数个，则PF&#x3D;1，否则PF&#x3D;0？</li><li>进位标志CF(carry flag) ：表示最高位是否进位或借位。 有进位或借位：CF&#x3D;1；无：CF&#x3D;0</li><li>辅助进位标志AF(auxiliary carry flag)：表示最低4位向 相邻高位是否有进位或借位。有，则AF&#x3D;1；否则，AF&#x3D;0</li><li>溢出标志OF(overflow flag) ：如果运算结果溢出，则OF&#x3D;1； 否则，OF&#x3D;0</li></ul><p>​3个控制标志位</p><ul><li><p>方向标志DF(direction flag) ：用来控制串操作指令的执行方向。</p><p>DF&#x3D;0：串操作指令的地址自动增量修改，串数据的处理过程是从低地址到高地址的方向进行<br>DF&#x3D;1：串操作指令的地址自动减量修改，串数据的处理过程是从高地址到低地址的方向进行</p></li><li><p>中断允许标志IF(interrupt enable flag)</p><p>IF&#x3D;1：CPU可响应外部可屏蔽中断请求；IF&#x3D;0：CPU不可响应外部可屏蔽中断请求</p></li><li><p>跟踪标志TF(trap flag)又称为单步标志</p><p>TF&#x3D;1：CPU以单步方式工作，每执行一条指令，执行一次内部中断。常用于程序的调试。</p><p>TF&#x3D;0：连续方式</p></li></ul><h3 id="总线接口部件BIU和执行部件EU的动作管理"><a href="#总线接口部件BIU和执行部件EU的动作管理" class="headerlink" title="总线接口部件BIU和执行部件EU的动作管理"></a>总线接口部件BIU和执行部件EU的动作管理</h3><ul><li>两个部件相互独立，并行工作，分别完成各自操作</li><li>两个部件相互配合，按照一定的规则，实现指令取指和执行的流水线操作</li></ul><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231120233136402.png" alt="image-20231120233136402"></p><h3 id="总线周期"><a href="#总线周期" class="headerlink" title="总线周期"></a>总线周期</h3><ol><li><p>时钟周期：</p><p>相邻两个时钟脉冲上升沿（下降沿）之间的时间间隔称为时钟周期（Clock Cycle），也称为 T状态(Time-State)。由计算机的主频决定（主频的倒数），是总线操作的最小时间单位</p></li><li><p>总线周期</p><p>8086CPU通过总线对外部(存储器或I&#x2F;O接口)进行一次访问所需的时间称为一个总线周期</p></li><li><p>指令周期</p><p>CPU从内存取一条指令并执行该条指令所用的时间。不同指令的指令周期长度是不同的</p></li><li><p>一个基本的总线周期通常包括4个时钟周期即T1, T2, T3和T4</p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231120234232640.png" alt="image-20231120234232640"></p></li></ol><ul><li><p>T1状态:CPU把要访问的存储单元或I&#x2F;O端口的地址输出到地址总线（A0～A19）上</p></li><li><p>T2状态: 撤销地址，将本总线周期的状态信息送高4位地址&#x2F;状态分时复用总线（A16&#x2F;S3～ A19&#x2F;S）用来表示中断允许状态和当前正在使用的寄存器。低16位（AD0～AD15）浮置成高阻抗状态</p></li><li><p>T3状态: 多路总线的高4位（A16&#x2F;S3～ A19&#x2F;S6 ）继续提供状态信息，而数据出现在数据线（AD0～AD15）上</p></li><li><p><strong>𝑇𝑤状态：等待状态，总线上保持T3时的信息状态</strong></p></li><li><p>T4状态: CPU完成读&#x2F;写数据，本总线周期结束</p></li></ul><ol start="5"><li><p>空闲状态𝑇𝑖(idle state）</p><p>当指令队列满，且EU无总线请求时，CPU的BIU进入空闲状态Ti</p><p>空闲状态出现在两个相邻的总线周期之间</p></li></ol><h2 id="8086的引脚信号和工作模式"><a href="#8086的引脚信号和工作模式" class="headerlink" title="8086的引脚信号和工作模式"></a>8086的引脚信号和工作模式</h2><h3 id="8086的工作模式"><a href="#8086的工作模式" class="headerlink" title="8086的工作模式"></a>8086的工作模式</h3><ol><li><p>最小模式：最小模式用于由单微处理器组成的小系统</p><p>特点：在最小模式的系统中，由8086CPU直接产生系统所需要的全部控制信号</p></li><li><p>最大模式：用于构成较大规模的8086系统，除了8086主处理器外，一般还有一个或多个协处理器</p><p>特点：8086和总线控制器8288共同形成系统总线信号</p></li><li><p>8086的工作模式由硬件连线来确定</p><p>MN&#x2F;MX*  接高电平+5V为最小模式</p><p>MN&#x2F;MX*  接低电平0为最大模式</p></li></ol><h3 id="8086的引脚信号和功能"><a href="#8086的引脚信号和功能" class="headerlink" title="8086的引脚信号和功能"></a>8086的引脚信号和功能</h3><p>重点关注：</p><ul><li>引脚的功能</li><li>信号的流向</li><li>有效电平</li><li>三态能力</li></ul><p>8086微处理器采用40条引脚的双列直插式封装</p><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231121085647430.png" alt="image-20231121085647430"></p><h4 id="公用的引脚信号和最小模式的引脚信号"><a href="#公用的引脚信号和最小模式的引脚信号" class="headerlink" title="公用的引脚信号和最小模式的引脚信号"></a>公用的引脚信号和最小模式的引脚信号</h4><h5 id="数据地址引脚"><a href="#数据地址引脚" class="headerlink" title="数据地址引脚"></a>数据地址引脚</h5><ol><li><p>AD15～AD0（Address&#x2F;Data）——地址&#x2F;数据分时复用引脚，双向、三态</p><p>在访问存储器或外设的总线操作周期中，在第一个时钟周期输出低16位地址</p></li><li><p>A19&#x2F;S6～A16&#x2F;S3（Address&#x2F;Status）——地址&#x2F;状态分时复用引脚，输出、三态</p><p>访问存储器，第一个时钟周期输出高四位地址；访问外设，第一个时钟周期全部输出低电平无效</p></li><li><p>各状态位介绍</p><p>S6 ：为低电平，表示8086与总线相连</p><p>S5 ：表示了中断允许标志的状态。当IF＝1 时S5置1，当IF＝0 时S5清0</p><p>S4和S3 ：指示是哪一个段寄存器正在被使用</p><table><thead><tr><th>S4S3＝00</th><th>CPU当前使用ES</th></tr></thead><tbody><tr><td>S4S3＝01</td><td>CPU当前使用SS</td></tr><tr><td>S4S3＝10</td><td>CPU当前使用CS或未用</td></tr><tr><td>S4S3＝11</td><td>CPU当前使用DS</td></tr></tbody></table></li><li><p>注意AD0——低8位数据的选通信号</p><p>在T1状态，AD0输出低电平，表示在T2、T3、T4状态，低8位数据线上的数据有效</p></li></ol><h5 id="读写控制引脚"><a href="#读写控制引脚" class="headerlink" title="读写控制引脚"></a>读写控制引脚</h5><ol><li><p>M&#x2F;IO*（Memory &#x2F; Input and Output）——存储器或I&#x2F;O访问，输出、三态</p><p>高电平：CPU将访问存储器，这时地址总线A19～A0提供20位存储器地址</p><p>低电平：CPU将访问I&#x2F;O端口，这时地址总线A15～A0提供16位I&#x2F;O端口地址</p></li><li><p>WR*（Write)——写控制，输出、三态、低电平有效</p><p>有效时，表示CPU正在写出数据给存储器或I&#x2F;O端口</p></li><li><p>RD*（Read）</p><p>有效时，表示CPU正在从存储器或I&#x2F;O端口读入数据</p></li></ol><table><thead><tr><th>总线周期</th><th>M&#x2F;IO*</th><th>WR*</th><th>RD*</th></tr></thead><tbody><tr><td>存储器读</td><td>高</td><td>高</td><td>低</td></tr><tr><td>存储器写</td><td>高</td><td>低</td><td>高</td></tr><tr><td>I&#x2F;O读</td><td>低</td><td>高</td><td>低</td></tr><tr><td>I&#x2F;O写</td><td>低</td><td>低</td><td>高</td></tr></tbody></table><ol start="4"><li><p>ALE（Address Latch Enable）——地址锁存允许，输出、三态、高电平有效</p><p>送给地址锁存器8282的控制信号，ALE在每个总线周期的T1输出高电平</p></li><li><p>DEN*（Data Enable)——数据允许，输出、三态、低电平有效</p><p>送给总线收发器8286的控制信号</p><p>有效时，表示当前数据总线上正在传送数据</p></li><li><p>DT&#x2F;R*（Data Transmit&#x2F;Receive）——数据发送&#x2F;接收，输出、三态</p><p>8086提供给8286的控制信号。表明当前总线上数据的流向。</p><p>高电平时数据自CPU输出（发送）；低电平时数据输入CPU（接收）</p></li><li><p>REDAY——存储器或I&#x2F;O口就绪，输入、高电平有效</p><p>总线操作周期中，8086CPU会在第3个时钟周期的前沿测试该引脚</p><p>如果测到高电平有效，CPU直接进入第4个时钟周期</p><p>如果测到无效，CPU将插入等待周期Tw</p></li><li><p>BHE*&#x2F;S7（Bus High Enable&#x2F;Status）——高8位数据总线允许&#x2F;状态，输出，低电平有效</p><p>在T1状态输出低电平时，表示高8位数据线上的数据有效</p><p>S7在8086中未定义，始终S7&#x3D;1</p></li><li><p><strong>BHE*和AD0配合进行数据的传输</strong>？</p></li></ol><ul><li><p>一个字节的传输</p><p>字节数据存储在偶地址存储单元中（10）</p><p>字节数据存储在奇地址存储单元中（01）</p></li><li><p>一个字的传输</p><p>规则字：一个总线周期即可传输完成（00）</p><p>非规则字：两个总线周期完成数据传输（01，10）</p></li><li><p>空闲状态（11）</p></li></ul><table><thead><tr><th>BHE*</th><th>AD0</th><th>AD8~AD15</th><th>AD0~AD7</th><th>操作</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>无效</td><td>有效</td><td>从偶地址开始字节操作</td></tr><tr><td>0</td><td>0</td><td>有效</td><td>有效</td><td>从偶地址开始字（规则字）操作</td></tr><tr><td>0</td><td>1</td><td>有效</td><td>无效</td><td>从奇地址开始字节操作</td></tr><tr><td>0</td><td>1</td><td>有效</td><td>无效</td><td>从奇地址开始字（非规则字）操作（两个总线周期</td></tr><tr><td>1</td><td>0</td><td>无效</td><td>有效</td><td>从奇地址开始字（非规则字）操作（两个总线周期</td></tr><tr><td>1</td><td>1</td><td>无效</td><td>无效</td><td>空闲周期</td></tr></tbody></table><p>非规则字：低地址为奇数，高地址为偶数</p><p>规则字：低地址为偶数，高地址为奇数</p><h5 id="中断请求和响应引脚"><a href="#中断请求和响应引脚" class="headerlink" title="中断请求和响应引脚"></a>中断请求和响应引脚</h5><ol><li><p>NMI（Non-Maskable Interrupt）——不可屏蔽中断请求，输入、上升沿有效</p><p>不受IF的影响，CPU会在当前指令结束之后，去执行中断类型号为2的中断处理程序</p><p>当系统发生紧急情况时，可通过它向CPU申请不可屏蔽中断服务</p></li><li><p>INTR（Interrupt Request）——可屏蔽中断请求，输入、高电平有效</p><p>CPU在每个指令周期的最后一个T状态对其采样，若为高电平，且IF＝1则CPU在结束当前指令后<br>去响应该中断，执行中断响应周期</p></li><li><p>INTA*（Interrupt Acknowledge）——可屏蔽中断响应，输出、低电平有效</p><p>有效时，表示来自INTR引脚的中断请求已被CPU响应，CPU进入中断响应周期</p><p>中断响应周期是连续的两个总线周期，每个周期的T2、T3、TW都发出有效的低电平响应信号，以便通知外设它们的中断请求已被响应，并令有关设备将中断类型号送到数据总线</p></li></ol><h5 id="总线请求和响应引脚"><a href="#总线请求和响应引脚" class="headerlink" title="总线请求和响应引脚"></a>总线请求和响应引脚</h5><ol><li><p>HOLD——总线保持（即总线请求），输入、高电平有效</p><p>有效时，表示总线请求设备向CPU申请使用总线</p><p>CPU在每个T状态的上升沿检测HOLD。若CPU允许就会在当前总线周期的T4发出响应信号，同时让出总线的使用权</p><p>该信号从有效到无效时，表示总线请求设备对总线的使用已经结束，通知CPU收回对总线的控制权</p></li><li><p>HLDA（HOLD Acknowledge）——总线保持响应（即总线响应），输出、高电平有效</p><p>有效时，表示CPU已响应总线请求并已将总线释放</p><p>此时CPU的地址总线、数据总线及具有三态输出能力的控制总线将全都呈现高阻，使总线请求设备可以顺利接管总线</p><p>待到总线请求信号HOLD无效，总线响应信号HLDA也转为无效，CPU重新获得总线控制权</p></li></ol><h5 id="其它引脚"><a href="#其它引脚" class="headerlink" title="其它引脚"></a>其它引脚</h5><ol><li><p>RESET——复位请求，输入、高电平有效</p><p>复位状态：指令队列清零，F、IP、DS、ES、SS清零，CS＝FFFFH</p><p>该信号至少要维持4个时钟周期的高电平才能完成复位过程，之后，当它返回低电平时，CPU将重新开始启动。</p><p>复位后CS＝0FFFFH、IP＝0000H，所以程序入口在物理地址FFFF0H</p></li><li><p>CLk（Clock）—— 时钟输入</p><p>时钟发生器8284A通过该引脚给CPU提供内部定时信号</p><p>最 高 频 率 对 8086 为 5MHz</p></li><li><p>Vcc——电源输入，向CPU提供＋5V电源</p></li><li><p>GND——接地，向CPU提供参考地电平</p></li><li><p>MN&#x2F; MX*（Minimum&#x2F;Maximum）——模式选择</p></li><li><p>TEST*——测试，输入，低电平有效</p><p>该引脚与WAIT指令配合使用</p><p> 当CPU执行WAIT指令时，它每隔5个时钟周期对该引脚进行测试：如果无效，则程序踏步并继续测<br>试；如果有效，则程序恢复运行。也就是说，WAIT指令使CPU产生等待，直到引脚有效为止</p></li></ol><h5 id="“引脚”小结"><a href="#“引脚”小结" class="headerlink" title="“引脚”小结"></a>“引脚”小结</h5><p><img src="/images/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231121162355582.png" alt="image-20231121162355582"></p><h4 id="最大模式的引脚信号"><a href="#最大模式的引脚信号" class="headerlink" title="最大模式的引脚信号"></a>最大模式的引脚信号</h4><h3 id="8086最大、最小模式的典型配置"><a href="#8086最大、最小模式的典型配置" class="headerlink" title="8086最大、最小模式的典型配置"></a>8086最大、最小模式的典型配置</h3><h4 id="最小模式的典型配置"><a href="#最小模式的典型配置" class="headerlink" title="最小模式的典型配置"></a>最小模式的典型配置</h4><ul><li>8086CPU</li><li>时钟发生器8284——1个</li><li>地址锁存器8282——3个</li><li>总线收发器8286——2个</li></ul><h4 id="最大模式的典型配置"><a href="#最大模式的典型配置" class="headerlink" title="最大模式的典型配置"></a>最大模式的典型配置</h4><ul><li>8086CPU</li><li>时钟发生器8284——1个</li><li>地址锁存器8282——3个</li><li>总线收发器8286——2个</li><li><strong>总线控制器8288——1个</strong></li></ul><h3 id="8086的操作和时序"><a href="#8086的操作和时序" class="headerlink" title="8086的操作和时序"></a>8086的操作和时序</h3>]]></content>
      
      
      <categories>
          
          <category> 微机原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>量子力学</title>
      <link href="/2023/11/20/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"/>
      <url>/2023/11/20/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><ol><li><p>波尔假设</p><p>定态：绕核运动的电子只能沿着一组特殊的轨道运动，并处于稳定状态，既不吸收也不发出辐射</p><p>量子跃迁：当电子由一个定态跃迁到另一个定态时，才产生辐射的吸收或发射的现象</p></li><li><p>波尔量子论的局限性</p><p>对复杂原子光谱无法处理</p><p>波尔理论仅能解决谱线频率问题，但不能求出谱线强度</p><p>波尔理论把微观粒子当做经典力学中的质点，以经典力学的方法解决微观粒子的运动规律，多少带点人为的性质，其物理本质还不清楚</p></li><li><p>德布罗意关系</p><p>注意和普朗克-爱因斯坦关系式的区分</p></li><li><p>自由粒子的德布罗意波以及自由粒子的德布罗意波的波长</p></li></ol><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="波函数的统计解释"><a href="#波函数的统计解释" class="headerlink" title="波函数的统计解释"></a>波函数的统计解释</h2><ul><li>电子衍射实验的波恩统计解释</li></ul><ol><li><p>波函数的统计解释</p><p>波函数在空间一点的强度（振幅绝对值的平方）和在该点找到粒子的概率成正比（概率波）</p></li><li><p>基本假设：波函数决定了粒子在空间任意一点出现的概率。波函数描写体系的量子状态</p></li><li><p>粒子在空间各点出现的概率总和为1</p></li><li><p>粒子在空间各点出现的概率仅仅取决于波函数在空间各点的相对强度。如果波函数在空间各点的振幅同时扩大一倍，并不会改变所描写的粒子状态</p></li></ol><ul><li>波函数的归一化</li></ul><h2 id="态叠加原理"><a href="#态叠加原理" class="headerlink" title="态叠加原理"></a>态叠加原理</h2><ul><li>概念</li></ul><ol><li>如果态Ψ1和态Ψ2是体系的可能状态，那么它们的线性叠加态Ψ也是体系的可能状态</li><li>当粒子处于Ψ1和Ψ2的线性叠加态Ψ时，粒子既处于态Ψ1，又处于态Ψ2</li></ol><ul><li>态的不同表示方式（坐标表象和动量表象）</li></ul><h2 id="薛定谔方程"><a href="#薛定谔方程" class="headerlink" title="薛定谔方程"></a>薛定谔方程</h2><ul><li>建立薛定谔方程的条件</li></ul><ol><li>波函数应满足含有对时间微商的微分方程</li><li>方程是线性的</li><li>方程系数不含状态参量（如动量，能量等）</li></ol><ul><li>建立薛定谔方程的简化步骤</li></ul><ol><li>写出体系能量E的表达式</li><li>表达式两边右乘波函数Ψ</li><li>代入能量算符和动量算符</li></ol><ul><li>薛定谔方程是量子力学的一个基本假设，它反应了微观粒子的运动规律。它的正确性是由各种具体情况下从方程得出的结论和实现结果相比较来验证的</li></ul><h2 id="定态薛定谔方程"><a href="#定态薛定谔方程" class="headerlink" title="定态薛定谔方程"></a>定态薛定谔方程</h2><ul><li>定态薛定谔方程</li><li>哈密顿算符</li><li>当体系处于能量算符本征函数所描写的状态（能量本征态）时，粒子的能量具有确定的数值，即本征值</li></ul><h2 id="一维无限深势阱（考大题）"><a href="#一维无限深势阱（考大题）" class="headerlink" title="一维无限深势阱（考大题）"></a>一维无限深势阱（考大题）</h2><ul><li>掌握求解一维无限深势阱的方法和对应解</li><li>系统的能量是量子化的，即所构成的能谱是离散的，且能级分布不均匀</li><li>粒子存在最低能级且不为0（基态n&#x3D;1，体系的能量最低的态称为基态），这是微观粒子波动性的表现</li><li>把在无限远处为0的波函数所描写的状态称为束缚态，束缚态所属的能级一般是分立的</li></ul><h2 id="线性谐振子"><a href="#线性谐振子" class="headerlink" title="线性谐振子"></a>线性谐振子</h2><ul><li><p>了解求解一维线性谐振子的方法（势能表达式）</p></li><li><p>掌握一维线性谐振子的能级表达式</p></li><li><p>系统的能量是量子化的，即所构成的能谱是离散的，且能级分布不均匀</p></li><li><p>粒子存在最低能级且不为0（基态n&#x3D;0），这是微观粒子波动性的表现</p></li></ul><h1 id="第三章——量子力学中的力学量"><a href="#第三章——量子力学中的力学量" class="headerlink" title="第三章——量子力学中的力学量"></a>第三章——量子力学中的力学量</h1><ul><li>掌握表示力学量的算符（动量算符和角动量算符）</li><li>掌握厄米算符本征函数的正交性与完备性</li><li>掌握算符与力学量的关系</li><li>掌握算符的对易关系，不确定关系</li></ul><h2 id="表示力学量的算符"><a href="#表示力学量的算符" class="headerlink" title="表示力学量的算符"></a>表示力学量的算符</h2><ul><li>算符的基本性质</li></ul><ol><li>算符相等</li><li>单位算符</li><li>算符之和</li><li>算符乘积</li><li>逆算符</li><li>函数内积</li><li>算符的复共轭</li><li>算符的转置算符：积分定义</li><li>算符的厄米共轭算符：积分定义</li><li>线性算符</li><li>算符的本征值和本征函数</li></ol><ul><li>量子力学的基本假设：如果算符F-表示力学量F，那么当体系处于算符F-的本征态φ时，力学量F有确定值，这个值就是在态φ中的本征值</li><li>量子力学中表示力学量的算符都是厄米算符，厄米算符的本征值都是实数</li></ul><h2 id="动量算符和角动量算符"><a href="#动量算符和角动量算符" class="headerlink" title="动量算符和角动量算符"></a>动量算符和角动量算符</h2><ul><li>动量算符</li></ul><ol><li>掌握求解动量本征函数的过程（注意归一化）</li><li>知道动量本征波函数的表达式</li></ol><ul><li>周期性边界条件（箱归一化）</li></ul><ol><li>目的：把动量连续本征值变为分立值，再把分立值变为连续值</li><li>方法：设想粒子限制在一个正方形的箱子中，取箱子的中点为坐标原点，要求波函数在两个相对的箱壁上对应的点具有相同的值</li><li>考虑周期性边界条件后，动量本征函数可以归一化</li></ol><ul><li>角动量算符</li></ul><ol><li>掌握角动量算符在x，y，z轴的分量</li><li>掌握算符Lz在球坐标下的具体表达式</li><li>掌握算符L^2的本征值方程</li><li>掌握算符Lz的本征值方程</li><li>掌握Lz的本征波函数的具体表达式以及其推导过程</li><li>把对应于一个本征值有一个以上的本征函数的情况称为简并，对应本征函数的数目称为简并度。</li><li>L^2的本征值是（2l+1）度简并的</li></ol><h2 id="电子在库伦场中的运动"><a href="#电子在库伦场中的运动" class="headerlink" title="电子在库伦场中的运动"></a>电子在库伦场中的运动</h2><ul><li>类氢原子电子势能，体系哈密顿算符</li><li>能量的表达式</li><li>库伦场中运动的电子能量小于0的定态波函数表达式（注意n，l，m的取值和表示的意义）</li><li>电子第n个能级是n^2度简并的</li></ul><h2 id="氢原子"><a href="#氢原子" class="headerlink" title="氢原子"></a>氢原子</h2><ul><li>了解一下</li></ul><h2 id="厄米算符本征函数的正交性"><a href="#厄米算符本征函数的正交性" class="headerlink" title="厄米算符本征函数的正交性"></a>厄米算符本征函数的正交性</h2><ul><li>定理：厄米算符的属于不同本征值的两个本征函数相互正交（<strong>该定理需要自己会证明</strong>）</li><li>掌握证明本征函数正交归一的方法</li><li>常见正交归一本征波函数的求解（算符Lz和一维无限深势阱）</li></ul><h2 id="算符与力学量的关系"><a href="#算符与力学量的关系" class="headerlink" title="算符与力学量的关系"></a>算符与力学量的关系</h2><ul><li>本征函数的完备性</li><li>基本假设：量子力学中表示力学量的算符都是厄米算符，它们的本征函数组构成完备系。</li><li>求解力学量均值的方法</li></ul><h2 id="算符的对易关系"><a href="#算符的对易关系" class="headerlink" title="算符的对易关系"></a>算符的对易关系</h2><ul><li>对易的基本操作</li><li>动量分量和其对应坐标不对易；动量分量和其不对应的坐标对易；动量分量对易</li><li><strong>定理：如果两个算符F和G有一组共同的本征函数Φn，而且Φn组成完全系，则算符F和G有对易</strong>（如角动量算符）</li><li>逆定理：如果两个算符对易，则这两个算符有组成完全系的共同本征函数</li><li>不确定关系（表达式）：反映了微观粒子的波粒二象性</li><li>力学量的完全集合：对于N个自由度的体系，需要有N个相互独立，其算符两两对易的力学量来完全确定体系的状态</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MCS-51单片机的硬件结构</title>
      <link href="/2023/11/19/MCS-51%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2023/11/19/MCS-51%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="MCS-51单片机的硬件结构"><a href="#MCS-51单片机的硬件结构" class="headerlink" title="MCS-51单片机的硬件结构"></a>MCS-51单片机的硬件结构</h1><h2 id="MCS-51的组成"><a href="#MCS-51的组成" class="headerlink" title="MCS-51的组成"></a>MCS-51的组成</h2><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119175759007.png" alt="image-20231119175759007"></p><h2 id="MCS-51的引脚"><a href="#MCS-51的引脚" class="headerlink" title="MCS-51的引脚"></a>MCS-51的引脚</h2><p>40只引脚双列直插封装（DIP）</p><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119175936599.png" alt="image-20231119175936599"></p><p>引脚逻辑图</p><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119180007389.png" alt="image-20231119180007389"></p><h3 id="电源及时钟引脚"><a href="#电源及时钟引脚" class="headerlink" title="电源及时钟引脚"></a>电源及时钟引脚</h3><ol><li>电源引脚</li></ol><ul><li>Vcc（40脚）：+5V电源</li><li>Vss（20脚）：接地</li></ul><ol start="2"><li>时钟引脚</li></ol><ul><li>XTAL1（19）：采用外部晶振时，此引脚接地</li><li>XTAL2（18）</li></ul><h3 id="控制引脚"><a href="#控制引脚" class="headerlink" title="控制引脚"></a>控制引脚</h3><ol><li><p>RST&#x2F;VPD（9）：复位与备用电源（一定宽度的高电平复位）</p></li><li><p>ALE&#x2F;PROG<em>（30）</em></p><p>第一功能ALE：地址锁存允许（后面介绍）</p><p>第二功能PROG*：编程脉冲输入端</p></li><li><p>PSEN*（29）：读取外部存储器的选通信号</p></li><li><p>EA*&#x2F;VPP（31）</p><p>第一功能：EA*为内外程序存储器选择控制,为低电平时单片机只访问外部程序存储器</p><p>第二功能：用于施加编程电压（不研究）</p></li></ol><h3 id="I-O口引脚"><a href="#I-O口引脚" class="headerlink" title="I&#x2F;O口引脚"></a>I&#x2F;O口引脚</h3><ol><li>P0口：双向8位三态I&#x2F;O口，地址总线（低8位）及数据总线的分时复用口</li><li>P1口：8位准双向I&#x2F;O口，可驱动4个TTL负载</li><li>P2口：8位准双向I&#x2F;O口，与地址总线（高8位）复用</li><li>P3口：8位准双向I&#x2F;O口，双功能复用口</li></ol><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119181609659.png" alt="image-20231119181609659"></p><p>准双向口和双向三态口的区别</p><ul><li>当三个准双向I&#x2F;O口做输入使用时，要向该口写1</li><li>准双向口无高阻的“浮空”状态</li></ul><h2 id="MCS-51的CPU（运算器和控制器）"><a href="#MCS-51的CPU（运算器和控制器）" class="headerlink" title="MCS-51的CPU（运算器和控制器）"></a>MCS-51的CPU（运算器和控制器）</h2><h3 id="运算器（对操作数进行算术、逻辑运算和位操作）"><a href="#运算器（对操作数进行算术、逻辑运算和位操作）" class="headerlink" title="运算器（对操作数进行算术、逻辑运算和位操作）"></a>运算器（对操作数进行算术、逻辑运算和位操作）</h3><ol><li>算术逻辑运算单元ALU</li><li>累加器A（Acc）</li></ol><ul><li>是ALU单元的输入之一，又是运算结果存放单元</li><li>是ALU单元的输入之一，又是运算结果存放单元</li><li>A的进位标志Cy同时又是位处理机的位累加器</li></ul><ol start="3"><li>程序状态字寄存器PSW</li></ol><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119182211785.png" alt="image-20231119182211785"></p><ul><li>Cy（PSW.7）进位标志位 </li><li>Ac   (PSW.6)   辅助进位标志位</li><li>F0（PSW.5）标志位——由用户使用的一个状态标志位</li><li>RS1、RS0（PSW.4、PSW.3）：4组工作寄存器区选择控制位1和位0</li></ul><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119182508472.png" alt="image-20231119182508472"></p><p>多组工作寄存器区可以保证数据的实时性，例如：当引入中断时，可以将RS0置1，改变中断程序使用的寄存器区，从而起到现场保护的作用。</p><ul><li>OV（PSW.2）溢出标志位：指示运算是否产生溢出（第三章详细介绍）</li><li>PSW.1位：保留位，未用</li><li>P(PSW.0)奇偶标志位：P&#x3D;1，A中“1”的个数为奇数；P&#x3D;0，A中“1”的个数为偶数</li></ul><p>奇偶标志位的应用：在串行通信中使用，提高串行通信的可靠性</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="程序计数器PC（Program-Counter）"><a href="#程序计数器PC（Program-Counter）" class="headerlink" title="程序计数器PC（Program Counter）"></a>程序计数器PC（Program Counter）</h4><p>作用：存放下一条要执行的指令在程序存储器中的地址</p><p>基本工作方式</p><ol><li><p>程序计数器自动加1</p></li><li><p>执行有条件或无条件转移指令时，程序计数器将被置入新的数值——&gt;程序流向发生变化</p></li><li><p>执行子程序调用或中断调用时完成下列操作</p></li></ol><ul><li>PC的当前值保护</li><li>将子程序入口地址或中断向量的地址送入PC</li></ul><h4 id="指令寄存器IR、指令译码器及控制逻辑电路"><a href="#指令寄存器IR、指令译码器及控制逻辑电路" class="headerlink" title="指令寄存器IR、指令译码器及控制逻辑电路"></a>指令寄存器IR、指令译码器及控制逻辑电路</h4><h2 id="MCS-51存储器结构"><a href="#MCS-51存储器结构" class="headerlink" title="MCS-51存储器结构"></a>MCS-51存储器结构</h2><p>哈佛（Har-vard）结构：程序存储器和外部数据存储器统一编址（冯诺依曼结构不是这样子的）</p><p>存储空间划分五类：程序存储器空间，内部数据存储器空间，外部数据存储器空间，SFR，位地址空间</p><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119183726572.png"></p><p>注意：图中特殊功能寄存器SFR在内部数据存储器空间是离散分布的</p><h3 id="程序存储器"><a href="#程序存储器" class="headerlink" title="程序存储器"></a>程序存储器</h3><p>作用：存放应用程序和表格之类的固定常数</p><p>组成：分为片内和片外两部分，由EA<em>引脚上所接电平确定，该引脚为低电平时接入外部程序存储器。*<em>程序存储器中的0000H地址是系统程序的启动地址</em></em></p><p>5个特殊单元：用作五种中断源的中断入口地址，即中断向量</p><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119184718530.png" alt="image-20231119184718530"></p><h3 id="内部数据存储器（128字节）"><a href="#内部数据存储器（128字节）" class="headerlink" title="内部数据存储器（128字节）"></a>内部数据存储器（128字节）</h3><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119184957720.png" alt="image-20231119184957720"></p><h3 id="特殊功能寄存器SFR（21个）"><a href="#特殊功能寄存器SFR（21个）" class="headerlink" title="特殊功能寄存器SFR（21个）"></a>特殊功能寄存器SFR（21个）</h3><p>作用：51单片机通过写SFR来控制相应功能部件（定时器、串口、中断等）的工作方式，同时SFR也综合的、实际的反映了整个单片机系统内部的工作状态。例如：PSW</p><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119185229054.png" alt="image-20231119185229054"></p><p><strong>注意：有的SFR可进行位寻址，其字节地址的末位是0H或8H</strong></p><p>下面是SFR中某些寄存器的简介：</p><ol><li><p>堆栈指针SP</p><p>指示出堆栈顶部在内部RAM块中的位置</p><p>堆栈向上生长，出栈后入先出</p><p>上电复位后SP内容默认为07H，作用是保护断点（PC）和现场保护（对Rn压栈）</p><p>由于07H与工作寄存器区重叠，因此使用前先赋值，一般用60H</p></li><li><p>数据指针DPTR</p><p>16位特殊功能寄存器，高位字节寄存器用DPH表示，低位字节寄存器用DPL表示</p></li><li><p>I&#x2F;O端口P0～P3</p><p>P0～P3分别为I&#x2F;O端口P0～P3的锁存器</p></li><li><p>寄存器B</p><p>为执行乘法和除法操作设置的</p><p>在不执行乘、除的情况下，可当作一个普通寄存器来使用</p></li><li><p>串行数据缓冲器SBUF</p><p>存放欲发送或已接收的数据，一个字节地址，物理上是由两个独立的寄存器组成，一个是发送缓冲器，另一个是接收缓冲器</p></li><li><p>定时器&#x2F;计数器</p><p>两个16位定时器&#x2F;计数器T1和T0，各由两个独立的8位寄存器组成： TH1、TL1、TH0、TL0，只能字<br>节寻址，但不能把T1或T0当作一个16位寄存器来寻址访问</p></li></ol><h3 id="位地址空间"><a href="#位地址空间" class="headerlink" title="位地址空间"></a>位地址空间</h3><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119190252438.png" alt="image-20231119190252438"></p><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119190303846.png" alt="image-20231119190303846"></p><ul><li>内部RAM的可寻址位128个(字节地址20H～2FH)，特殊功能寄存器SFR为83个可寻址位，共211个</li><li>SFR中字节地址为X0H或X8H的单元可以位寻址</li></ul><h3 id="外部数据存储器"><a href="#外部数据存储器" class="headerlink" title="外部数据存储器"></a>外部数据存储器</h3><ol><li><p>地址的重叠性</p><p><strong>程序存储器与数据存储器全部64K字节地址空间重叠</strong>。程序存储器与数据存储器在使用上是严格区分的：有不同的物理接线（PSEN*），不同的指令控制（MOVC和MOVX）</p></li><li><p><strong>片外数据存储区中，RAM与I&#x2F;O端口统一编址</strong>。所有外围I&#x2F;O端口的地址均占用RAM地址单元，使用与访问<br>外部数据存储器相同的传送指令</p></li></ol><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119191044634.png" alt="image-20231119191044634"></p><p>上图是52系列单片机，不同点在于多了一个128字节的片内数据存储单元，它与SFR采用的寻址方式不同</p><p>SFR用直接寻址，片内RAM用简间接寻址</p><h2 id="并行I-O端口"><a href="#并行I-O端口" class="headerlink" title="并行I&#x2F;O端口"></a>并行I&#x2F;O端口</h2><p><strong>共有4个8位双向I&#x2F;O口，共32口线。每位均有自己的锁存器(SFR)，输出驱动器和输入缓冲器</strong></p><h3 id="P0口内部结构"><a href="#P0口内部结构" class="headerlink" title="P0口内部结构"></a>P0口内部结构</h3><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119195411346.png" alt="image-20231119195411346"></p><ol><li>控制信号为0时，P0做双向I&#x2F;O口，为漏极开路</li><li>控制信号为1时，P0为地址&#x2F;数据复用总线</li><li>POW为端口输出写信号，用于锁存输出状态</li><li>POR1为读锁存器信号，执行“ANL P0，#0FH”时该信号有效</li><li>POR2为读引脚信号，执行“MOV A，P0”时该信号有效</li></ol><h3 id="P1口内部结构"><a href="#P1口内部结构" class="headerlink" title="P1口内部结构"></a>P1口内部结构</h3><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119195925828.png" alt="image-20231119195925828"></p><p>特点：输出部分有内部上拉电阻R*约为20k</p><p>注意：读引脚时先写入1，其它部分与P0端口使用相类似</p><p>读锁存器</p><ul><li><p>读锁存器指令是从锁存器中读取数据，进行处理，并把处理后的数据重新写入锁存器中，这类指令称为读、<br>修改、写指令。</p></li><li><p>在ANL、ORL、XRL； JBC； CPL；INC、DEC； DJNZ； MOV、 CLR、 SETB等指令中，当目的操作数为某一I／O口或I／O口的某一位时，这些指令均为读、修改、写指令。</p></li></ul><p>读端口</p><ul><li>读端口指令一般都是以I&#x2F;O端口为源操作数的指令，执行读引脚指令时，打开三态门，输入口状态。例如，读P1口的输入状态时，读引脚指令为：MOV  A，P1。</li></ul><p>区分读端口和读锁存器</p><ul><li>当给口锁存器写入某一状态后，相应的口引脚是否呈现锁存器的状态，是与外电路的连接有关。如三极管，写1后，外部三极管导通，这样基级电平为0，读锁存器和读引脚就不一致了。</li></ul><h3 id="P2口内部结构"><a href="#P2口内部结构" class="headerlink" title="P2口内部结构"></a>P2口内部结构</h3><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119200958405.png" alt="image-20231119200958405"></p><ol><li>P2可以作为通用的I&#x2F;O，也可做为高八位地址输出（一般用作地址输出）</li><li>当控制信号为1时，P2口输出地址信息</li><li>当P2作为普通I&#x2F;O口使用时用法和P1口类似</li></ol><h3 id="P3口内部结构"><a href="#P3口内部结构" class="headerlink" title="P3口内部结构"></a>P3口内部结构</h3><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119201500357.png" alt="image-20231119201500357"></p><ol><li><p>做普通端口使用时，第二功能应为“1”</p></li><li><p>使用第二功能时，输出端口锁存器应为“1”</p></li><li><p>变异功能</p></li></ol><table><thead><tr><th>P3.0</th><th>P3.1</th><th>P3.2</th><th>P3.3</th><th>P3.4</th><th>P3.5</th><th>P3.6</th><th>P3.7</th></tr></thead><tbody><tr><td>TXD</td><td>RXD</td><td>INT0</td><td>INT1</td><td>T0</td><td>T1</td><td>WR</td><td>RD</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>P0～P3口都是并行I&#x2F;O口，但P0口和P2口还可用来构建数据总线和地址总线，所以电路中有一个MUX，进行转换（MUX是Multiplexer，即多路复用器）</p></li><li><p>只有P0口是一个真正的双向口，P1～P3口都是准双向口</p><p>原因:P0口作数据总线使用时，为保证数据正确传送，需解决芯片内外的隔离问题，即只有在数据传送时芯片内外才接通；否则应处于隔离状态。为此，P0口的输出缓冲器应为三态门</p></li><li><p>P3口具有第二功能。因此在P3口电路增加了第二功能控制逻辑。这是P3口与其它各口的不同之处</p></li><li><p>设计8051系统时，要对51的I&#x2F;O管脚统一规划使用。一个管脚不能既作为输入，又作为输出。换言之，一个管脚如果第一次用其为输入，一直用其作为输入管脚。</p></li><li><p>通常情况下P0和P2就用作数据&#x2F;地址总线使用，P0低8位，P2高8位。</p></li></ol><h2 id="时钟电路与时序"><a href="#时钟电路与时序" class="headerlink" title="时钟电路与时序"></a>时钟电路与时序</h2><p>时钟电路用于产生单片机工作所必须的时间控制信号</p><h3 id="时钟电路"><a href="#时钟电路" class="headerlink" title="时钟电路"></a>时钟电路</h3><p>时钟频率直接影响单片机的速度，电路的质量直接影响系统的稳定性</p><ol><li>内部时钟方式</li></ol><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119202922754.png" alt="image-20231119202922754"></p><ul><li><p>内部有一个用于构成振荡器的高增益反相放大器，其输入端：XTAL1，输出端：XTAL2</p></li><li><p>C1和C2典型值通常选择为30pF左 右</p></li><li><p>晶体的振荡频率在1.2MHz～12MHz之间，某些高速单片机芯片的时钟频率已达40MHz（这里指51）</p></li></ul><ol start="2"><li>外部时钟方式——常用于多片MCS-51单片机同时工作</li></ol><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119203250877.png" alt="image-20231119203250877"></p><h3 id="机器周期、指令周期与指令时序"><a href="#机器周期、指令周期与指令时序" class="headerlink" title="机器周期、指令周期与指令时序"></a>机器周期、指令周期与指令时序</h3><ol><li>时钟周期——单片机的基本时间单位，时钟周期为晶振频率的倒数</li><li>机器周期——CPU完成一个基本操作所需要的时间，MCS-51单片机每12个时钟周期为一个机器周期</li></ol><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119203850489.png" alt="image-20231119203850489"></p><ol start="3"><li>指令周期——执行一条指令时，可分为取指令阶段和指令执行阶段</li></ol><ul><li><p>取指令阶段，PC中地址送到程序存储器，并从中取出需要执行指令的操作码和操作数</p></li><li><p>指令执行阶段，对指令操作码进行译码，以产生一系列控制信号完成指令的执行</p></li><li><p><strong>ALE信号是为地址锁存而定义的，以时钟脉冲1&#x2F;6的频率出现，在一个机器周期中，ALE信号两次有效</strong>（注意，在执行访问外部数据存储器的指令MOVX时，将会丢失一个ALE脉冲）</p></li></ul><h2 id="复位操作和复位电路"><a href="#复位操作和复位电路" class="headerlink" title="复位操作和复位电路"></a>复位操作和复位电路</h2><ol><li>复位操作</li></ol><ul><li><p>复位操作是单片机的初始化操作，摆脱死锁状态</p></li><li><p>在引脚RST加上大于2个机器周期（即24个时钟振荡周期）的高电平就可使MCS-51复位</p></li><li><p>复位时，PC初始化为0000H，使MCS-51单片机从0000H单元开始执行程序</p></li><li><p>除PC之外，复位操作还对其它一些寄存器有影响（SP&#x3D;07H ，P0-P3的引脚均为高电平）</p></li></ul><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119204627973.png" alt="image-20231119204627973"></p><ul><li>在复位有效期间，ALE脚和PSEN*脚均为高电平，内部RAM的状态不受复位的影响</li></ul><ol start="2"><li>复位电路</li></ol><ul><li>片内复位结构</li></ul><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119204958645.png" alt="image-20231119204958645"></p><ul><li>上电自动复位和按钮复位</li></ul><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119205052481.png" alt="image-20231119205052481"></p><ul><li>按键手动复位（有电平方式和脉冲方式）</li></ul><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119205204546.png" alt="image-20231119205204546"></p><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119205326337.png" alt="image-20231119205326337"></p><p>上图（b）中的电路能输出高、低两种电平的复位控制信 号，以适应外围I&#x2F;O接口芯片所要求的不同复位电平信号。74LS122为单稳电路，实验表明，电容C的选择约为0.1μF较好。还可采用专用的复位管理芯片如IMP813L、TL7705等</p>]]></content>
      
      
      <categories>
          
          <category> 单片机原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>定时/计数器</title>
      <link href="/2023/11/19/%E5%AE%9A%E6%97%B6-%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
      <url>/2023/11/19/%E5%AE%9A%E6%97%B6-%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-定时计数器"><a href="#第六章-定时计数器" class="headerlink" title="第六章 定时计数器"></a>第六章 定时计数器</h1><h2 id="定时计数器的结构框图"><a href="#定时计数器的结构框图" class="headerlink" title="定时计数器的结构框图"></a>定时计数器的结构框图</h2><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119152943798.png" alt="image-20231119152943798"></p><h2 id="定时器的控制字"><a href="#定时器的控制字" class="headerlink" title="定时器的控制字"></a>定时器的控制字</h2><h3 id="TMOD：工作方式控制寄存器（89H）"><a href="#TMOD：工作方式控制寄存器（89H）" class="headerlink" title="TMOD：工作方式控制寄存器（89H）"></a>TMOD：工作方式控制寄存器（89H）</h3><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119153057581.png" alt="image-20231119153057581"></p><ol><li>GATE：门控位</li></ol><ul><li>GATE&#x3D;1，INT0引脚控制T0运行，INT1引脚控制T1运行，可测量这两引脚出现的正脉冲宽度</li><li>GATE&#x3D;0，定时计数器的运行不受外部引脚INT1或INT0的控制</li></ul><ol start="2"><li>C&#x2F;T：计数器模式和定时器模式的选择位</li></ol><ul><li>C&#x2F;T&#x3D;0时，定时器模式。每个机器周期定时器加一</li><li>C&#x2F;T&#x3D;1时，计数器模式。外部相应输入脚T0（p3.4）或T1（p3.5）产生下降沿时，计数器加一</li></ul><ol start="3"><li>M1、M0：工作方式 选择位</li></ol><table><thead><tr><th>M0</th><th align="left">M1</th><th>工作方式</th></tr></thead><tbody><tr><td>0</td><td align="left">0</td><td>方式0：TLX中低五位与THX中8位组成十三位计数器</td></tr><tr><td>1</td><td align="left">0</td><td>方式1：TLX与THX组成16位计数器</td></tr><tr><td>0</td><td align="left">1</td><td>方式2：常数自动重装载的8位计数器，相当于TLX溢出时，将THX中的内容赋给了TLX</td></tr><tr><td>1</td><td align="left">1</td><td>方式3：仅适用于T0，分成两个8位计数器，T1停止计数</td></tr></tbody></table><ol start="4"><li>注意：TMOD不能位寻址</li></ol><h3 id="TCON：控制寄存器（88H）"><a href="#TCON：控制寄存器（88H）" class="headerlink" title="TCON：控制寄存器（88H）"></a>TCON：控制寄存器（88H）</h3><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119154859192.png" alt="image-20231119154859192"></p><ul><li><p>TF1：T1计数溢出标志位。由硬件控制，计数溢出时，由硬件置1。<strong>进入中断服务程序后被硬件自动清零</strong>。</p></li><li><p>TR1：T1计数运行控制位。由软件控制。</p><pre><code>当GATE位（TMOD.7）＝0时，若TR1=1，允许T1计数当GATE位=1时，TR1＝1且INT1=1时，允许T1计数</code></pre></li><li><p>TF0：T0计数溢出标志位，功能同TF1。</p></li><li><p>TR0：T0计数运行控制位，由软件置1或清0。</p><pre><code>当GATE位（TMOD.3）＝0时，若TR0=1，允许T0计数当GATE位=1时，TR0＝1且INT0=1时，允许T0计数。</code></pre></li></ul><h2 id="定时-计数器的四种工作方式"><a href="#定时-计数器的四种工作方式" class="headerlink" title="定时&#x2F;计数器的四种工作方式"></a>定时&#x2F;计数器的四种工作方式</h2><ol><li><p>T1工作在方式0的等效框图</p><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119160056978.png" alt="image-20231119160056978"></p></li></ol><ul><li>GATE&#x3D;0时，A点始终为1，B点的控制始终由TR1决定</li><li>GATE&#x3D;1时，A点由INT1引脚控制，因此B点由TR1和INT1共同决定</li><li>C&#x2F;T低电平接内部时钟，高电平接外部引脚</li><li>方式1和方式0控制方式完全相同，只是一个是16位计数器，一个是13位计数器</li></ul><ol start="2"><li><p>T1工作在方式2等效框图</p><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119160704137.png" alt="image-20231119160704137"></p></li></ol><ul><li>相当于自动赋初值，初值为TH1</li><li>该方式可以简化定时常数的计算方法（确定计数初值），可相当精确的确定定时时间，例：波特率发生器</li></ul><ol start="3"><li><p>工作于方式3的T0</p><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119161137288.png" alt="image-20231119161137288"></p></li></ol><ul><li>TL0使用T0的状态控制位C&#x2F;T, GATE,TR0, INT0，而TH0被固定为一个8位定时器（不能作外部计数方式），并<strong>使用定时器T1的状态控制位TR1和TF1，同时占用定时器T1的中断源</strong>。</li><li>此时T1可以工作在方式0~2，但最好工作在方式2，经常做为串行口波特率发生器</li></ul><p><img src="/images/%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86/image-20231119161848107.png" alt="image-20231119161848107"></p><h2 id="定时-计数器的输入信号"><a href="#定时-计数器的输入信号" class="headerlink" title="定时&#x2F;计数器的输入信号"></a>定时&#x2F;计数器的输入信号</h2><h3 id="工作于定时器方式"><a href="#工作于定时器方式" class="headerlink" title="工作于定时器方式"></a>工作于定时器方式</h3><p>对内部时钟信号计数，内部时钟信号的频率为时钟振荡频率的1&#x2F;12，即每个机器周期计数值加1</p><h3 id="工作于计数器方式"><a href="#工作于计数器方式" class="headerlink" title="工作于计数器方式"></a>工作于计数器方式</h3><p>计数脉冲来自外部输入引脚T0或T1。当输入信号产生由1至0的跳变（即下跳变）时，计数器的值增1</p>]]></content>
      
      
      <categories>
          
          <category> 单片机原理 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
